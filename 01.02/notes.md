## 1.2 Procedures and the Processes They Generate

> In this section we will examine some common “shapes” for processes generated by simple procedures. We will also investigate the rates at which these processes consume the important computational resources of time and space.


### 1.2.1 Linear Recursion and Iteration

Here's a procedure to calculate factorials using the linear recursion pattern. It takes advantage of the fact that $ n! = n * (n-1)! $

```lisp
(define (factorial n)
  (if (= n 1) 
      1 
      (* n (factorial (- n 1)))))
```

Here, no state is being passed to each procedure call. The state for what multiplications have to be made is kept on the stack of calls. This can be observed by expanding the operation with the substitution rule

```lisp
(factorial 6)
(* 6 (factorial 5))
(* 6 (* 5 (factorial 4)))
(* 6 (* 5 (* 4 (factorial 3))))
(* 6 (* 5 (* 4 (* 3 (factorial 2)))))
(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))
(* 6 (* 5 (* 4 (* 3 (* 2 1)))))
(* 6 (* 5 (* 4 (* 3 2))))
(* 6 (* 5 (* 4 6)))
(* 6 (* 5 24))
(* 6 120)
720 
```

The interpreter has to keep track of a chain of *deferred operations*, which grows linearly with the size of the input. This kind of process is called a *linear recursive process*.

Conversely, we could multiply 1 by 2, then by 3, then 4, and so on until reaching $ n $. We would need some variables to hold that running product, and how many steps we've calculated already. Those variables would track the *state* of the running operation.

```lisp
(define (factorial n)
  (fact-iter 1 1 n))

(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* product counter)
                 (+ counter 1)
                 max-count)))
```

Here's the same operation from before, visualized via substitution model:

```lisp
(factorial 6)
(fact-iter 1 1 6)
(fact-iter 1 2 6)
(fact-iter 2 3 6)
(fact-iter 6 4 6)
(fact-iter 24 5 6)
(fact-iter 120 6 6)
(fact-iter 720 7 6)
720
```

All the information necessary to keep on with the operation is encapsulated by the state variables, and there are no deferred operations for the interpreter to track. This is called a *linear iterative process*.

#### Recursive process vs Recursive procedure

Notice the difference between a *recursive process* and a *recursive procedure*. `fact-iter` is defined as a function of itself, so it's a recursive procedure, but in this case this recursion is really just a different way to express a loop which could be easily converted to a `for` or `while` block in another language.

Because of that, it's considered to be an iterative process, not a recursive one.

Many languages are not able to distinguish between those two kinds of process in a recursive procedure, making it so that they always consume increasing amounts of memory even if the process is iterative.

Some languages (including Scheme) are able to detect this difference though, and optimize iterative processes to execute in constant space even when described by a recursive procedures. This optimization is called *tail recursion*.

